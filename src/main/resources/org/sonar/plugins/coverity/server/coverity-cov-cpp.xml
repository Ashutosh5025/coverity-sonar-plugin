<rules>
    <rule>
        <key>STATIC_C_PW.PRINTF_ARG_MISMATCH_none</key>
        <name>API usage errors : Printf arg type mismatch</name>
        <internalKey>STATIC_C_PW.PRINTF_ARG_MISMATCH_none</internalKey>
        <description>A printf format string does not match the types of one of the arguments</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SLEEP_none</key>
        <name>Program hangs : Waiting while holding a lock</name>
        <internalKey>STATIC_C_SLEEP_none</internalKey>
        <description>A lock is held while waiting for a long running or blocking operation to complete</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_HFA_none</key>
        <name>Build system issues : Unnecessary header file</name>
        <internalKey>STATIC_C_HFA_none</internalKey>
        <description>A header file was included but none of its contents were used in the rest of the source file</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_LOCK_none</key>
        <name>Concurrent data access violations : Data race condition</name>
        <internalKey>STATIC_C_MISSING_LOCK_none</internalKey>
        <description>Thread shared data is accessed without holding an appropriate lock, possibly causing a race condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.NAMING_naming_L</key>
        <name>Code maintainability issues : Symbian - missing L suffix</name>
        <internalKey>STATIC_C_SYMBIAN.NAMING_naming_L</internalKey>
        <description>Violation of the Symbian naming convention: leaving functions should contain L in their suffix</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.NAMING_naming_LC</key>
        <name>Code maintainability issues : Symbian - missing LC suffix</name>
        <internalKey>STATIC_C_SYMBIAN.NAMING_naming_LC</internalKey>
        <description>Violation of the Symbian naming convention: functions that push an element to the cleanup stack should contain LC in their suffix</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.NAMING_none</key>
        <name>Code maintainability issues : Symbian - naming convention</name>
        <internalKey>STATIC_C_SYMBIAN.NAMING_none</internalKey>
        <description>Violation of the Symbian naming convention</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SW.*</key>
        <name>Coverity SW : Semantic Warnings</name>
        <internalKey>STATIC_C_SW.*</internalKey>
        <description>Coverity SW : Semantic Warnings</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>semantic-warning</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_LOCK_double_lock</key>
        <name>Program hangs : Double lock</name>
        <internalKey>STATIC_C_LOCK_double_lock</internalKey>
        <description>Attempt to acquire a lock more than once on a non-recursive lock</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_LOCK_lock_assert</key>
        <name>API usage errors : Lock assertion failure</name>
        <internalKey>STATIC_C_LOCK_lock_assert</internalKey>
        <description>A lock assertion fails because a lock is not held on a path where it is asserted</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_LOCK_missing_unlock</key>
        <name>Program hangs : Missing unlock</name>
        <internalKey>STATIC_C_LOCK_missing_unlock</internalKey>
        <description>Missing a release of a lock on a path</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_LOCK_none</key>
        <name>Program hangs : Double lock or missing unlock</name>
        <internalKey>STATIC_C_LOCK_none</internalKey>
        <description>Missing a release of a lock on a path, or an attempt to acquire a lock more than once</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINTENDED_INTEGER_DIVISION_none</key>
        <name>Incorrect expression : Result is not floating-point</name>
        <internalKey>STATIC_C_UNINTENDED_INTEGER_DIVISION_none</internalKey>
        <description>When dividing two values of integer types, integer division is used, which ignores any remainder. When such a result is used in a context expecting a floating-point number, it is likely that floating-point division was intended.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_ALLOC_ARITHMETIC_none</key>
        <name>Memory - corruptions : Stray pointer arithmetic</name>
        <internalKey>STATIC_C_BAD_ALLOC_ARITHMETIC_none</internalKey>
        <description>Pointer arithmetic performed on freshly allocated memory</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIGN_EXTENSION_none</key>
        <name>Integer handling issues : Unintended sign extension</name>
        <internalKey>STATIC_C_SIGN_EXTENSION_none</internalKey>
        <description>Value may be sign extended unintentionally</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RESOURCE_LEAK_exceptional_path</key>
        <name>Exceptional resource leaks : Resource leak on an exceptional path</name>
        <internalKey>STATIC_C_RESOURCE_LEAK_exceptional_path</internalKey>
        <description>Leak of a system resource on an exception path (probably error handling)</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RESOURCE_LEAK_fds_handles</key>
        <name>Resource leaks : Integer handle or fd leak</name>
        <internalKey>STATIC_C_RESOURCE_LEAK_fds_handles</internalKey>
        <description>Leak of a system resource with an integer descriptor such as a file descriptor or a handle in Windows</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RESOURCE_LEAK_none</key>
        <name>Resource leaks : Resource leak</name>
        <internalKey>STATIC_C_RESOURCE_LEAK_none</internalKey>
        <description>Leak of memory or pointers to system resources</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_none</key>
        <name>API usage errors : Printf arg count mismatch</name>
        <internalKey>STATIC_C_PW.TOO_MANY_PRINTF_ARGS_none</internalKey>
        <description>The number of arguments to printf does not match the format string</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DC.WEAK_CRYPTO_none</key>
        <name>Security best practices violations : Calling risky function</name>
        <internalKey>STATIC_C_DC.WEAK_CRYPTO_none</internalKey>
        <description>The called function is unsafe for security related code</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_array_index_read</key>
        <name>Insecure data handling : Untrusted array index read</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_array_index_read</internalKey>
        <description>Read from array at index computed using an unscrutinized value from an untrusted source</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_array_index_write</key>
        <name>Insecure data handling : Untrusted array index write</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_array_index_write</internalKey>
        <description>Write to array at index computed using an unscrutinized value from an untrusted source</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_critical_argument</key>
        <name>Insecure data handling : Untrusted value as argument</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_critical_argument</internalKey>
        <description>An unscrutinized value from an untrusted source used as argument to a function (for example, a buffer size)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_loop_bound</key>
        <name>Insecure data handling : Untrusted loop bound</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_loop_bound</internalKey>
        <description>An unscrutinzed value from an untrusted source used as a loop upper bound</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_none</key>
        <name>Insecure data handling : Use of untrusted scalar value</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_none</internalKey>
        <description>An unscrutinized value from an untrusted source used in a trusted context</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_pointer_deref_read</key>
        <name>Insecure data handling : Untrusted pointer read</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_pointer_deref_read</internalKey>
        <description>Reads target of a pointer computed using an unscrutinized value from an untrusted source</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_SCALAR_pointer_deref_write</key>
        <name>Insecure data handling : Untrusted pointer write</name>
        <internalKey>STATIC_C_TAINTED_SCALAR_pointer_deref_write</internalKey>
        <description>Write to target of pointer computed using an unscrutinized value from an untrusted source</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_PARSE_ERROR_none</key>
        <name>Parse warnings : Unrecoverable parse warning</name>
        <internalKey>STATIC_C_PARSE_ERROR_none</internalKey>
        <description>A parse error caused an entire compilation unit to be skipped by Coverity Static Analysis</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_classpath</key>
        <name>Low impact security : Cleartext sensitive data in a JAR file</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_classpath</internalKey>
        <description>Reading sensitive data from a resource in the classpath.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_cookie</key>
        <name>High impact security : Cleartext sensitive data in a cookie</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_cookie</internalKey>
        <description>Reading unencrypted sensitive data from a cookie.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_database</key>
        <name>Medium impact security : Cleartext sensitive data in a database</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_database</internalKey>
        <description>Reading unencrypted sensitive data from a database.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_file</key>
        <name>Low impact security : Cleartext sensitive data in a file</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_in_file</internalKey>
        <description>Reading unencrypted sensitive data from a file.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_transmission</key>
        <name>High impact security : Cleartext transmission of sensitive data</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_cleartext_transmission</internalKey>
        <description>Receiving sensitive data in cleartext from the network.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_none</key>
        <name>High impact security : Missing encryption of sensitive data</name>
        <internalKey>STATIC_C_UNENCRYPTED_SENSITIVE_DATA_none</internalKey>
        <description>Retrieving or receiving unencrypted sensitive data.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.*</key>
        <name>Coverity PW : Parse Warnings</name>
        <internalKey>STATIC_C_PW.*</internalKey>
        <description>Coverity PW : Parse Warnings</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>parse-warning</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.INCLUDE_RECURSION_none</key>
        <name>Build system issues : Recursion in included headers</name>
        <internalKey>STATIC_C_PW.INCLUDE_RECURSION_none</internalKey>
        <description>Recursion in included header files</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_none</key>
        <name>Incorrect expression : Assign instead of compare</name>
        <internalKey>STATIC_C_PW.ASSIGN_WHERE_COMPARE_MEANT_none</internalKey>
        <description>An assignment (=) occurs where compare (==) is probably intended</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STREAM_FORMAT_STATE_none</key>
        <name>API usage errors : Not restoring ostream format</name>
        <internalKey>STATIC_C_STREAM_FORMAT_STATE_none</internalKey>
        <description>Not restoring the stream format state of an ostream</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STREAM_FORMAT_STATE_suspicious_setf_mask</key>
        <name>API usage errors : Unknown mask in setf</name>
        <internalKey>STATIC_C_STREAM_FORMAT_STATE_suspicious_setf_mask</internalKey>
        <description>setf (or a similar) was called, but the argument was not recognized as being composed of valid format state bits</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_WARNING_no_null_terminator</key>
        <name>Memory - illegal accesses : Buffer not null terminated</name>
        <internalKey>STATIC_C_BUFFER_SIZE_WARNING_no_null_terminator</internalKey>
        <description>The string buffer may not have a null terminator if the source string&apos;s length is equal to the buffer size</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_WARNING_none</key>
        <name>Memory - illegal accesses : Buffer not null terminated</name>
        <internalKey>STATIC_C_BUFFER_SIZE_WARNING_none</internalKey>
        <description>The string buffer may not have a null terminator if the source string&apos;s length is equal to the buffer size</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_RETURN_multiple_returns</key>
        <name>Code maintainability issues : Multiple return statements</name>
        <internalKey>STATIC_C_MISSING_RETURN_multiple_returns</internalKey>
        <description>Multiple return statements violates local coding standard</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_RETURN_none</key>
        <name>Uninitialized variables : Missing return statement</name>
        <internalKey>STATIC_C_MISSING_RETURN_none</internalKey>
        <description>Function that returns non-void is missing a return value</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MIXED_ENUMS_inferred</key>
        <name>Incorrect expression : Inferred misuse of enum</name>
        <internalKey>STATIC_C_MIXED_ENUMS_inferred</internalKey>
        <description>An integer expression which was inferred to have an enum type is mixed with a different enum type</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MIXED_ENUMS_none</key>
        <name>Incorrect expression : Mixing enum types</name>
        <internalKey>STATIC_C_MIXED_ENUMS_none</internalKey>
        <description>An enum-typed expression is mixed with a different enum type</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_REVERSE_INULL_none</key>
        <name>Null pointer dereferences : Dereference before null check</name>
        <internalKey>STATIC_C_REVERSE_INULL_none</internalKey>
        <description>All paths that lead to this null pointer comparison already dereference the pointer earlier</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNCAUGHT_EXCEPT_none</key>
        <name>Error handling issues : Uncaught exception</name>
        <internalKey>STATIC_C_UNCAUGHT_EXCEPT_none</internalKey>
        <description>A C++ exception is thrown but never caught</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_ASSIGN_none</key>
        <name>Rule violations : Missing assignment operator</name>
        <internalKey>STATIC_C_MISSING_ASSIGN_none</internalKey>
        <description>Class that owns resources lacks a user-written assignment operator</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_ASSIGN_uncalled</key>
        <name>Rule violations : Missing assignment operator</name>
        <internalKey>STATIC_C_MISSING_ASSIGN_uncalled</internalKey>
        <description>Class that owns resources lacks a user-written assignment operator</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_USELESS_CALL_none</key>
        <name>Incorrect expression : Useless call</name>
        <internalKey>STATIC_C_USELESS_CALL_none</internalKey>
        <description>A function is called that is only useful for its return value, and this value is ignored.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BAD_FREE_none</key>
        <name>Memory - illegal accesses : Explicit free of COM interface</name>
        <internalKey>STATIC_C_COM.BAD_FREE_none</internalKey>
        <description>A COM interface is explicitly freed instead of using the recommended Release method</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.INTEGER_TOO_LARGE_none</key>
        <name>Integer handling issues : Integer overflow warning</name>
        <internalKey>STATIC_C_PW.INTEGER_TOO_LARGE_none</internalKey>
        <description>An integer overflow occurs at compile time when parsing this expression</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_bit_and_with_zero</key>
        <name>Integer handling issues : Bitwise-and with zero</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_bit_and_with_zero</internalKey>
        <description>Bitwise-and (&apos;&amp;amp;&apos;) operation applied to zero always produces zero</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_extra_high_bits</key>
        <name>Integer handling issues : Extra high-order bits</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_extra_high_bits</internalKey>
        <description>In an operation, the high-order bits of wider operand do not affect the narrower operand</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_logical_vs_bitwise</key>
        <name>Integer handling issues : Logical vs. bitwise operator</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_logical_vs_bitwise</internalKey>
        <description>Logical operator used in place of bitwise operator or vice versa</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_missing_parentheses</key>
        <name>Incorrect expression : Missing parentheses</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_missing_parentheses</internalKey>
        <description>Missing parentheses caused unintended operator precedence</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_none</key>
        <name>Integer handling issues : Constant expression result</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_none</internalKey>
        <description>An operation with non-constant operands that computes a result with constant value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_operator_confusion</key>
        <name>Integer handling issues : Wrong operator used</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_operator_confusion</internalKey>
        <description>Wrong operator used in expression</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_pointless_string_compare</key>
        <name>Incorrect expression : Pointless string comparison</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_pointless_string_compare</internalKey>
        <description>A string is compared against itself with strcmp or strncmp.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_result_independent_of_operands</key>
        <name>Integer handling issues : Operands don&apos;t affect result</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_result_independent_of_operands</internalKey>
        <description>An operation with non-constant operands that computes a result with constant value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_same_on_both_sides</key>
        <name>Incorrect expression : Same on both sides</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_same_on_both_sides</internalKey>
        <description>The same expression occurs on both sides of an operator.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CONSTANT_EXPRESSION_RESULT_unnecessary_op_assign</key>
        <name>Integer handling issues : Suspicious &amp;= or |=</name>
        <internalKey>STATIC_C_CONSTANT_EXPRESSION_RESULT_unnecessary_op_assign</internalKey>
        <description>Using a bitwise assignment operator to assign a constant value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ORDER_REVERSAL_none</key>
        <name>Program hangs : Thread deadlock</name>
        <internalKey>STATIC_C_ORDER_REVERSAL_none</internalKey>
        <description>Threads may try to acquire two locks in different orders, potentially causing deadlock</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_crypto</key>
        <name>Medium impact security : Use of hard-coded cryptographic key</name>
        <internalKey>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_crypto</internalKey>
        <description>A cryptographic key is stored directly in the source code.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_passwd</key>
        <name>Medium impact security : Use of hard-coded password</name>
        <internalKey>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_passwd</internalKey>
        <description>A password is stored directly in the source code.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_token</key>
        <name>Medium impact security : Use of hard-coded security token</name>
        <internalKey>STATIC_C_HARDCODED_CREDENTIALS_hardcoded_credential_token</internalKey>
        <description>A security token is stored directly in the source code.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_HARDCODED_CREDENTIALS_none</key>
        <name>Medium impact security : Use of hard-coded credentials</name>
        <internalKey>STATIC_C_HARDCODED_CREDENTIALS_none</internalKey>
        <description>Credentials are stored directly in the source code</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_coverity-cov-cpp</key>
        <name>Coverity General COV-CPP</name>
        <internalKey>STATIC_C_coverity-cov-cpp</internalKey>
        <description>Coverity General COV-CPP</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INVALIDATE_ITERATOR_none</key>
        <name>API usage errors : Using invalid iterator</name>
        <internalKey>STATIC_C_INVALIDATE_ITERATOR_none</internalKey>
        <description>An invalid or past-the-end iterator is being used</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.CONV_none</key>
        <name>Memory - corruptions : COM bad conversion to BSTR</name>
        <internalKey>STATIC_C_COM.BSTR.CONV_none</internalKey>
        <description>A wide character string cannot be converted to a BSTR because it lacks the hidden length field</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STACK_USE_none</key>
        <name>Performance inefficiencies : Large stack use</name>
        <internalKey>STATIC_C_STACK_USE_none</internalKey>
        <description>Excessive use of stack memory by local variables or parameters</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ALLOC_FREE_MISMATCH_none</key>
        <name>API usage errors : Incorrect deallocator used</name>
        <internalKey>STATIC_C_ALLOC_FREE_MISMATCH_none</internalKey>
        <description>A resource is freed using the wrong deallocator</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_STRING_format_string</key>
        <name>Insecure data handling : Format string vulnerability</name>
        <internalKey>STATIC_C_TAINTED_STRING_format_string</internalKey>
        <description>An unscrutinized value from an untrusted source used to construct a format string</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_STRING_none</key>
        <name>Insecure data handling : Use of untrusted string value</name>
        <internalKey>STATIC_C_TAINTED_STRING_none</internalKey>
        <description>An unscrutinized string from an untrusted source used in a trusted context</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_SHIFT_none</key>
        <name>Integer handling issues : Bad bit shift operation</name>
        <internalKey>STATIC_C_BAD_SHIFT_none</internalKey>
        <description>A bit shift operation has a shift amount which is too large or has a negative value.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INFINITE_LOOP_no_escape</key>
        <name>Program hangs : Infinite loop with no exit</name>
        <internalKey>STATIC_C_INFINITE_LOOP_no_escape</internalKey>
        <description>Infinite loop with no exit condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INFINITE_LOOP_none</key>
        <name>Program hangs : Infinite loop</name>
        <internalKey>STATIC_C_INFINITE_LOOP_none</internalKey>
        <description>Infinite loop with unsatisfiable exit condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_BREAK_none</key>
        <name>Control flow issues : Missing break in switch</name>
        <internalKey>STATIC_C_MISSING_BREAK_none</internalKey>
        <description>Missing break statement between cases in switch statement</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRING_OVERFLOW_fixed_size_dest</key>
        <name>Security best practices violations : Copy into fixed size buffer</name>
        <internalKey>STATIC_C_STRING_OVERFLOW_fixed_size_dest</internalKey>
        <description>A source buffer of statically unknown size is copied into a fixed-size destination buffer</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRING_OVERFLOW_likely_overflow</key>
        <name>Memory - corruptions : Destination buffer too small</name>
        <internalKey>STATIC_C_STRING_OVERFLOW_likely_overflow</internalKey>
        <description>Size of destination buffer is smaller than the size of the source buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRING_OVERFLOW_none</key>
        <name>Memory - corruptions : Buffer overflow</name>
        <internalKey>STATIC_C_STRING_OVERFLOW_none</internalKey>
        <description>Size of destination buffer is smaller than the size of the source buffer or size of the source buffer is unknown</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_ALLOC_STRLEN_none</key>
        <name>Memory - corruptions : String length miscalculation</name>
        <internalKey>STATIC_C_BAD_ALLOC_STRLEN_none</internalKey>
        <description>String length miscalculation</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SECURE_CODING_none</key>
        <name>Security best practices violations : Calling risky function</name>
        <internalKey>STATIC_C_SECURE_CODING_none</internalKey>
        <description>Calling a function which may pose a security risk if it is used inappropriately</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_COPY_OR_ASSIGN_none</key>
        <name>Memory - illegal accesses : Missing assignment operator</name>
        <internalKey>STATIC_C_MISSING_COPY_OR_ASSIGN_none</internalKey>
        <description>Class that owns resources lacks a user-written assignment operator</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_COPY_OR_ASSIGN_uncalled</key>
        <name>Rule violations : Missing assignment operator</name>
        <internalKey>STATIC_C_MISSING_COPY_OR_ASSIGN_uncalled</internalKey>
        <description>Class that owns resources lacks a user-written assignment operator</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_none</key>
        <name>API usage errors : Printf arg count mismatch</name>
        <internalKey>STATIC_C_PW.TOO_FEW_PRINTF_ARGS_none</internalKey>
        <description>The number of arguments to printf does not match the format string</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_PASSWORD_HASH_none</key>
        <name>High impact security : Weak password hashing</name>
        <internalKey>STATIC_C_WEAK_PASSWORD_HASH_none</internalKey>
        <description>Hashing a password using a scheme that is not computationally intensive, and/or without using a random and unique salt as part of the input.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_PASSWORD_HASH_weak_hash</key>
        <name>Medium impact security : Hashing a password with a weak hash function</name>
        <internalKey>STATIC_C_WEAK_PASSWORD_HASH_weak_hash</internalKey>
        <description>Hashing a password using a scheme that is not computationally intensive.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_PASSWORD_HASH_weak_hash_no_salt</key>
        <name>High impact security : Very weak password hashing</name>
        <internalKey>STATIC_C_WEAK_PASSWORD_HASH_weak_hash_no_salt</internalKey>
        <description>Hashing a password using a scheme that is not computationally intensive, and without using any salt as part of the input.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_PASSWORD_HASH_weak_hash_weak_salt</key>
        <name>High impact security : Weak password hashing</name>
        <internalKey>STATIC_C_WEAK_PASSWORD_HASH_weak_hash_weak_salt</internalKey>
        <description>Hashing a password using a scheme that is not computationally intensive, and without using a random and unique salt as part of the input.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_PASSWORD_HASH_weak_salt</key>
        <name>Low impact security : Hashing a password with a weak salt</name>
        <internalKey>STATIC_C_WEAK_PASSWORD_HASH_weak_salt</internalKey>
        <description>Hashing a password without using a random and unique salt as part of the input.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_COPY_none</key>
        <name>Rule violations : Missing copy constructor</name>
        <internalKey>STATIC_C_MISSING_COPY_none</internalKey>
        <description>Class that owns resources lacks a user-written copy constructor</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_COPY_uncalled</key>
        <name>Rule violations : Missing copy constructor</name>
        <internalKey>STATIC_C_MISSING_COPY_uncalled</internalKey>
        <description>Class that owns resources lacks a user-written copy constructor</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_EVALUATION_ORDER_none</key>
        <name>Incorrect expression : Evaluation order violation</name>
        <internalKey>STATIC_C_EVALUATION_ORDER_none</internalKey>
        <description>Statement contains multiple side-effects on the same value with an undefined evaluation order</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_array_null</key>
        <name>Incorrect expression : Array compared against 0</name>
        <internalKey>STATIC_C_NO_EFFECT_array_null</internalKey>
        <description>Array compared against NULL pointer</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_bad_memset_fill_value</key>
        <name>Memory - illegal accesses : Memset fill value of &apos;0&apos;</name>
        <internalKey>STATIC_C_NO_EFFECT_bad_memset_fill_value</internalKey>
        <description>A memset fill value of ASCII character &apos;0&apos; is likely intended to be 0</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_bad_memset_truncated_fill</key>
        <name>Memory - illegal accesses : Memset fill truncated</name>
        <internalKey>STATIC_C_NO_EFFECT_bad_memset_truncated_fill</internalKey>
        <description>The memset fill value must be between -1 and 255, other values will be truncated</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_bad_memset_zero_size</key>
        <name>Memory - illegal accesses : Memset buffer size of 0</name>
        <internalKey>STATIC_C_NO_EFFECT_bad_memset_zero_size</internalKey>
        <description>A memset buffer size of 0 may indicate confusing the size and fill parameters</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_bool_switch</key>
        <name>Incorrect expression : Switch test assignment</name>
        <internalKey>STATIC_C_NO_EFFECT_bool_switch</internalKey>
        <description>A boolean test within a switch condition is likely an intended assignment</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_extra_comma</key>
        <name>Incorrect expression : Misused comma operator</name>
        <internalKey>STATIC_C_NO_EFFECT_extra_comma</internalKey>
        <description>Comma operator has a left sub-expression with no side-effects</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_incomplete_delete</key>
        <name>Resource leaks : Incomplete delete</name>
        <internalKey>STATIC_C_NO_EFFECT_incomplete_delete</internalKey>
        <description>Delete operator only applies to one argument in a comma expression, may cause memory leak</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_no_effect_deref</key>
        <name>Incorrect expression : Incorrect pointer increment</name>
        <internalKey>STATIC_C_NO_EFFECT_no_effect_deref</internalKey>
        <description>Increment (or decrement) of pointer value, not the value pointed-to</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_no_effect_test</key>
        <name>Incorrect expression : Test should be assignment</name>
        <internalKey>STATIC_C_NO_EFFECT_no_effect_test</internalKey>
        <description>A test that is an isolated statement with no effect is likely an intended assignment</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_self_assign</key>
        <name>Incorrect expression : Self assignment</name>
        <internalKey>STATIC_C_NO_EFFECT_self_assign</internalKey>
        <description>Assignment of a variable or expression to itself has no effect</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_unsigned_compare</key>
        <name>Control flow issues : Unsigned compared against 0</name>
        <internalKey>STATIC_C_NO_EFFECT_unsigned_compare</internalKey>
        <description>An unsigned value can never be less than 0</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_unsigned_compare_macros</key>
        <name>Integer handling issues : Macro compares unsigned to 0</name>
        <internalKey>STATIC_C_NO_EFFECT_unsigned_compare_macros</internalKey>
        <description>An unsigned value can never be less than 0</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_unsigned_enums</key>
        <name>Integer handling issues : Enum compared against 0</name>
        <internalKey>STATIC_C_NO_EFFECT_unsigned_enums</internalKey>
        <description>An enumeration value is usually not less than 0</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_static_through_instance</key>
        <name>Miscellaneous : Unnecessary instance object usage</name>
        <internalKey>STATIC_C_NO_EFFECT_static_through_instance</internalKey>
        <description>A static field or method is accessed using an instance object</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NO_EFFECT_none</key>
        <name>Miscellaneous : Unnecessary instance object usage</name>
        <internalKey>STATIC_C_NO_EFFECT_none</internalKey>
        <description>A static field or method is accessed using an instance object</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_OPEN_ARGS_none</key>
        <name>API usage errors : Insecure file permissions</name>
        <internalKey>STATIC_C_OPEN_ARGS_none</internalKey>
        <description>The open system call may create a file, but no permissions are specified</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_array_index_read</key>
        <name>Memory - illegal accesses : Uninitialized array index read</name>
        <internalKey>STATIC_C_UNINIT_array_index_read</internalKey>
        <description>Read from array at uninitialized index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_array_index_write</key>
        <name>Memory - corruptions : Uninitialized array index write</name>
        <internalKey>STATIC_C_UNINIT_array_index_write</internalKey>
        <description>Write to array at uninitialized index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_none</key>
        <name>Uninitialized variables : Uninitialized scalar variable</name>
        <internalKey>STATIC_C_UNINIT_none</internalKey>
        <description>Use of an uninitialized variable</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_pointer_deref_read</key>
        <name>Memory - illegal accesses : Uninitialized pointer read</name>
        <internalKey>STATIC_C_UNINIT_pointer_deref_read</internalKey>
        <description>Reads an uninitialized pointer or its target</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_pointer_deref_write</key>
        <name>Memory - corruptions : Uninitialized pointer write</name>
        <internalKey>STATIC_C_UNINIT_pointer_deref_write</internalKey>
        <description>Write to target of an uninitialized pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHECKED_RETURN_library_function</key>
        <name>Error handling issues : Unchecked return value from library</name>
        <internalKey>STATIC_C_CHECKED_RETURN_library_function</internalKey>
        <description>Value returned from a library function is not checked for errors before being used.  This value may indicate an error condition.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHECKED_RETURN_none</key>
        <name>Error handling issues : Unchecked return value</name>
        <internalKey>STATIC_C_CHECKED_RETURN_none</internalKey>
        <description>Value returned from a function is not checked for errors before being used</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHECKED_RETURN_short_read</key>
        <name>Error handling issues : Ignoring number of bytes read</name>
        <internalKey>STATIC_C_CHECKED_RETURN_short_read</internalKey>
        <description>Value returned from a function and indicating the number of bytes read is ignored.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHECKED_RETURN_unchecked_arg</key>
        <name>Error handling issues : Unchecked return value as arg</name>
        <internalKey>STATIC_C_CHECKED_RETURN_unchecked_arg</internalKey>
        <description>Value returned from a function is not checked for errors, and passed directly to another function as an argument</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHECKED_RETURN_user_required</key>
        <name>Error handling issues : Unchecked return value from user code</name>
        <internalKey>STATIC_C_CHECKED_RETURN_user_required</internalKey>
        <description>Value returned from a program function is not checked before being used.  It has been marked that its return value should always be checked.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_SIZEOF_none</key>
        <name>Incorrect expression : Incorrect sizeof expression</name>
        <internalKey>STATIC_C_BAD_SIZEOF_none</internalKey>
        <description>The sizeof operator was applied to an unintended variable or expression, such as a pointer variable instead of its target</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_SIZEOF_sizeof_ptr_expr</key>
        <name>Incorrect expression : Sizeof pointer expression</name>
        <internalKey>STATIC_C_BAD_SIZEOF_sizeof_ptr_expr</internalKey>
        <description>The sizeof operator was applied to a pointer expression, which may not be intended</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_extra_sizeof</key>
        <name>Incorrect expression : Extra sizeof expression</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_extra_sizeof</internalKey>
        <description>The sizeof operator is not required in the expression</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_missing_parentheses</key>
        <name>Memory - illegal accesses : Missing parentheses</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_missing_parentheses</internalKey>
        <description>Missing parentheses caused unintended operator precedence of casting before the pointer arithmetic</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_none</key>
        <name>Incorrect expression : Misused sizeof</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_none</internalKey>
        <description>The sizeof operator is used erroneously in an expression or is invoked on the wrong argument</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_sizeof_punning</key>
        <name>Code maintainability issues : Sizeof not portable</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_sizeof_punning</internalKey>
        <description>The sizeof operator is used on a wrong argument that incidentally has the same size</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_wrong_size_value</key>
        <name>Incorrect expression : Wrong size argument</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_wrong_size_value</internalKey>
        <description>The wrong size value is passed to a function</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZEOF_MISMATCH_wrong_sizeof</key>
        <name>Incorrect expression : Wrong sizeof argument</name>
        <internalKey>STATIC_C_SIZEOF_MISMATCH_wrong_sizeof</internalKey>
        <description>The sizeof operator is invoked on the wrong argument</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_double_free</key>
        <name>Memory - illegal accesses : COM BSTR double free</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_double_free</internalKey>
        <description>Violation of the COM coding standard by freeing a BSTR more than once</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_free_uninit</key>
        <name>Memory - illegal accesses : COM BSTR uninitialized var free</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_free_uninit</internalKey>
        <description>Violation of the COM coding standard by freeing an uninitialized BSTR</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_leak</key>
        <name>Resource leaks : COM BSTR memory leak</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_leak</internalKey>
        <description>Violation of the COM coding standard by not freeing a BSTR whose last reference is lost in this function</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_none</key>
        <name>Memory - illegal accesses : COM BSTR error</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_none</internalKey>
        <description>Violation of the COM coding standard by not freeing a BSTR, or by freeing a non-owned BSTR</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_use_after_free</key>
        <name>Memory - illegal accesses : Freeing non-owned COM BSTR</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_use_after_free</internalKey>
        <description>Violation of the COM coding standard by freeing a non-owned BSTR</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.ALLOC_use_uninit</key>
        <name>Memory - illegal accesses : COM BSTR uninitialized var use</name>
        <internalKey>STATIC_C_COM.BSTR.ALLOC_use_uninit</internalKey>
        <description>Violation of the COM coding standard by using an uninitialized BSTR</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ATOMICITY_none</key>
        <name>Concurrent data access violations : Value not atomically updated</name>
        <internalKey>STATIC_C_ATOMICITY_none</internalKey>
        <description>Non-atomic update of a concurrently shared value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.ADDROF_LEAK_none</key>
        <name>Resource leaks : Managed pointer overwrite</name>
        <internalKey>STATIC_C_COM.ADDROF_LEAK_none</internalKey>
        <description>A non-null pointer managed by a CComBSTR or CComPtr instance is passed by address to a function call. The value of the pointer can potentially be overwritten during the function call causing allocated memory to be leaked.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_fixed_size_dest</key>
        <name>Security best practices violations : Copy into fixed size buffer</name>
        <internalKey>STATIC_C_BUFFER_SIZE_fixed_size_dest</internalKey>
        <description>A source buffer of statically unknown size is copied into a fixed-size destination buffer</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_likely_overflow</key>
        <name>Memory - corruptions : Destination buffer too small</name>
        <internalKey>STATIC_C_BUFFER_SIZE_likely_overflow</internalKey>
        <description>Size of destination buffer is smaller than the size argument specified</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_no_null_terminator</key>
        <name>Memory - illegal accesses : Buffer not null terminated</name>
        <internalKey>STATIC_C_BUFFER_SIZE_no_null_terminator</internalKey>
        <description>The string buffer may not have a null terminator if the source string&apos;s length is equal to the buffer size</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_none</key>
        <name>Security best practices violations : Possible buffer overflow</name>
        <internalKey>STATIC_C_BUFFER_SIZE_none</internalKey>
        <description>Incorrect buffer manipulation may result in buffer overflow</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BUFFER_SIZE_overlapping_buffer</key>
        <name>API usage errors : Overlapping buffer in memory copy</name>
        <internalKey>STATIC_C_BUFFER_SIZE_overlapping_buffer</internalKey>
        <description>Buffers may be overlapping in a string copy function</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_address</key>
        <name>Memory - corruptions : Free of address-of expression</name>
        <internalKey>STATIC_C_BAD_FREE_address</internalKey>
        <description>Free of an address-of expression, which can never be heap allocated</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_alloca</key>
        <name>Memory - corruptions : Free of stack-allocated memory</name>
        <internalKey>STATIC_C_BAD_FREE_alloca</internalKey>
        <description>Free of stack-allocated buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_array</key>
        <name>Memory - corruptions : Free of array-typed value</name>
        <internalKey>STATIC_C_BAD_FREE_array</internalKey>
        <description>Free of array-typed value</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_first_field_address</key>
        <name>Memory - corruptions : Free of address-of first field</name>
        <internalKey>STATIC_C_BAD_FREE_first_field_address</internalKey>
        <description>Free of an address-of the first field of a struct</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_function_pointer</key>
        <name>Memory - corruptions : Free of function pointer</name>
        <internalKey>STATIC_C_BAD_FREE_function_pointer</internalKey>
        <description>Free of function pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_FREE_none</key>
        <name>Memory - corruptions : Free of invalid pointer value</name>
        <internalKey>STATIC_C_BAD_FREE_none</internalKey>
        <description>Free of an pointer that was not returned from an allocation function</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DC.STREAM_BUFFER_none</key>
        <name>Security best practices violations : Calling risky function</name>
        <internalKey>STATIC_C_DC.STREAM_BUFFER_none</internalKey>
        <description>The called function is unsafe for security related code</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_ampersand_in_size</key>
        <name>Memory - corruptions : Allocation size with &apos;&amp;&apos;</name>
        <internalKey>STATIC_C_SIZECHECK_ampersand_in_size</internalKey>
        <description>Allocation size is computed using the bitwise-and operator (&amp;amp;), which is likely to be a typo</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_improper_new</key>
        <name>Memory - corruptions : Incorrect operator new syntax</name>
        <internalKey>STATIC_C_SIZECHECK_improper_new</internalKey>
        <description>This invocation of operator new only creates one value, not an array of values</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_incorrect_multiplication</key>
        <name>Memory - corruptions : Allocation size mismatch</name>
        <internalKey>STATIC_C_SIZECHECK_incorrect_multiplication</internalKey>
        <description>Allocation size is not a multiple of the target pointer&apos;s pointed-to type</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_likely_overflow</key>
        <name>Memory - corruptions : Allocation too small for type</name>
        <internalKey>STATIC_C_SIZECHECK_likely_overflow</internalKey>
        <description>Allocation size is too small for the type of object being allocated</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_no_null_terminator</key>
        <name>Memory - corruptions : Allocation too small for string</name>
        <internalKey>STATIC_C_SIZECHECK_no_null_terminator</internalKey>
        <description>Allocation size for a string is equal to the strlen of another string, which does not include extra byte for null termination</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SIZECHECK_none</key>
        <name>Memory - illegal accesses : Allocation size error</name>
        <internalKey>STATIC_C_SIZECHECK_none</internalKey>
        <description>The allocation size is computed incorrectly</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_VIRTUAL_DTOR_empty_dtor</key>
        <name>Code maintainability issues : Empty virtual destructor</name>
        <internalKey>STATIC_C_VIRTUAL_DTOR_empty_dtor</internalKey>
        <description>The correct derived class destructor that happens to be empty is not invoked due to the absence of a virtual destructor in the base class</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_VIRTUAL_DTOR_none</key>
        <name>Resource leaks : Non-virtual destructor</name>
        <internalKey>STATIC_C_VIRTUAL_DTOR_none</internalKey>
        <description>The correct derived class destructor is not invoked due to the absence of a virtual destructor in the base class</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_none</key>
        <name>Security best practices violations : Non-constant format string</name>
        <internalKey>STATIC_C_PW.NON_CONST_PRINTF_FORMAT_STRING_none</internalKey>
        <description>A non-constant printf format string may be susceptible to format string attacks</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ENUM_AS_BOOLEAN_none</key>
        <name>Incorrect expression : Misuse of enum</name>
        <internalKey>STATIC_C_ENUM_AS_BOOLEAN_none</internalKey>
        <description>An enum-typed expression is used in a Boolean conditional context.  The enum type does not appear to have a distinguished false (zero) value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NULL_RETURNS_none</key>
        <name>Null pointer dereferences : Dereference null return value</name>
        <internalKey>STATIC_C_NULL_RETURNS_none</internalKey>
        <description>Return value of function which returns null is dereferenced without checking</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NULL_RETURNS_unimpl</key>
        <name>Null pointer dereferences : Dereference null return (stat)</name>
        <internalKey>STATIC_C_NULL_RETURNS_unimpl</internalKey>
        <description>Return value of function, which is statistically inferred to return null, but with no source code available, is dereferenced</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_READLINK_none</key>
        <name>Memory - illegal accesses : Readlink used insecurely</name>
        <internalKey>STATIC_C_READLINK_none</internalKey>
        <description>The readlink system call may return a value equal to the buffer size, which causes an access one past the end</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_REVERSE_NEGATIVE_array_index_read</key>
        <name>Memory - illegal accesses : Negative array index read</name>
        <internalKey>STATIC_C_REVERSE_NEGATIVE_array_index_read</internalKey>
        <description>Read from array at negative index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_REVERSE_NEGATIVE_array_index_write</key>
        <name>Memory - corruptions : Negative array index write</name>
        <internalKey>STATIC_C_REVERSE_NEGATIVE_array_index_write</internalKey>
        <description>Write to array at negative index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_REVERSE_NEGATIVE_critical_argument</key>
        <name>Memory - corruptions : Argument cannot be negative</name>
        <internalKey>STATIC_C_REVERSE_NEGATIVE_critical_argument</internalKey>
        <description>Negative value used as argument to a function expecting a positive value (for example, size of buffer or allocation)</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_REVERSE_NEGATIVE_none</key>
        <name>Integer handling issues : Improper use of negative value</name>
        <internalKey>STATIC_C_REVERSE_NEGATIVE_none</internalKey>
        <description>Negative value used incorrectly where positive value is expected</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA.*</key>
        <name>Coverity MISRA : Coding Standard Violation</name>
        <internalKey>STATIC_C_MISRA.*</internalKey>
        <description>Coverity MISRA : Coding Standard Violation</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>misra</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RETURN_LOCAL_escape_local_addr_to_fields_or_globals</key>
        <name>Memory - illegal accesses : Pointer to local outside scope</name>
        <internalKey>STATIC_C_RETURN_LOCAL_escape_local_addr_to_fields_or_globals</internalKey>
        <description>Pointer to a local stack variable stored in a field or global variable</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RETURN_LOCAL_none</key>
        <name>Memory - illegal accesses : Pointer to local outside scope</name>
        <internalKey>STATIC_C_RETURN_LOCAL_none</internalKey>
        <description>Pointer to a local stack variable returned or used outside scope</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_none</key>
        <name>Memory - illegal accesses : Returning pointer to temp</name>
        <internalKey>STATIC_C_PW.RETURN_PTR_TO_LOCAL_TEMP_none</internalKey>
        <description>Returning a pointer to a temporary variable, which will be destroyed on function exit</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SWAPPED_ARGUMENTS_none</key>
        <name>API usage errors : Arguments in wrong order</name>
        <internalKey>STATIC_C_SWAPPED_ARGUMENTS_none</internalKey>
        <description>The arguments to a function call are provided in the wrong order.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHAR_IO_none</key>
        <name>API usage errors : Truncated stdio return value</name>
        <internalKey>STATIC_C_CHAR_IO_none</internalKey>
        <description>Stdio character-oriented I/O functions return int values such as EOF not representable by char variables</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_none</key>
        <name>Integer handling issues : Integer overflow warning</name>
        <internalKey>STATIC_C_PW.SHIFT_COUNT_TOO_LARGE_none</internalKey>
        <description>An integer overflow occurs at compile time when parsing this expression</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DELETE_ARRAY_non_array_delete</key>
        <name>Memory - illegal accesses : Array delete misuse</name>
        <internalKey>STATIC_C_DELETE_ARRAY_non_array_delete</internalKey>
        <description>Using array delete on a non-array</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DELETE_ARRAY_none</key>
        <name>Memory - illegal accesses : Incorrect delete operator</name>
        <internalKey>STATIC_C_DELETE_ARRAY_none</internalKey>
        <description>Using non-array delete on an array of objects, scalars, or pointers allocated with new[]</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DELETE_ARRAY_object</key>
        <name>Resource leaks : Non-array delete for objects</name>
        <internalKey>STATIC_C_DELETE_ARRAY_object</internalKey>
        <description>Using non-array delete on an array of objects; should be using delete[]</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DELETE_ARRAY_scalar</key>
        <name>Compiler dependency : Non-array delete for scalars</name>
        <internalKey>STATIC_C_DELETE_ARRAY_scalar</internalKey>
        <description>Using non-array delete on an array of scalars or pointers allocated with new[]</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRING_SIZE_none</key>
        <name>Memory - corruptions : Unbounded source buffer</name>
        <internalKey>STATIC_C_STRING_SIZE_none</internalKey>
        <description>A source buffer of arbitrarily large size is used where a fixed-size destination buffer is expected</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNREACHABLE_none</key>
        <name>Control flow issues : Structurally dead code</name>
        <internalKey>STATIC_C_UNREACHABLE_none</internalKey>
        <description>Code block is unreachable because of the syntactic structure of the code</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_VARARGS_none</key>
        <name>API usage errors : Missing varargs init or cleanup</name>
        <internalKey>STATIC_C_VARARGS_none</internalKey>
        <description>Incorrect usage of variable argument macros; use va_start or va_copy to begin processing and va_end to finish</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CTOR_DTOR_LEAK_none</key>
        <name>Resource leaks : Resource leak in object</name>
        <internalKey>STATIC_C_CTOR_DTOR_LEAK_none</internalKey>
        <description>Constructor allocates memory but destructor does not free it</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RISKY_CRYPTO_custom</key>
        <name>Medium impact security : Violation of user-specified RISKY_CRYPTO policy</name>
        <internalKey>STATIC_C_RISKY_CRYPTO_custom</internalKey>
        <description>A cryptographic function was used in such a way as to violate the user-specified RISKY_CRYPTO policy. This violation may indicate that an attacker could decrypt or otherwise interfere with the encrypted or hashed data.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_RISKY_CRYPTO_hashing</key>
        <name>Medium impact security : Risky cryptographic hashing function</name>
        <internalKey>STATIC_C_RISKY_CRYPTO_hashing</internalKey>
        <description>A risky hashing function was used. This may allow an attacker to produce collisions on the hash or execute length extension attacks.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_RISKY_CRYPTO_none</key>
        <name>Medium impact security : Risky cryptographic function</name>
        <internalKey>STATIC_C_RISKY_CRYPTO_none</internalKey>
        <description>A risky cryptographic function was used. This may allow an attacker to decrypt encrypted data as the quality of the cryptographic protection is suspect.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_COM_deref_read_after_free</key>
        <name>Memory - illegal accesses : Freed COM internal read</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_COM_deref_read_after_free</internalKey>
        <description>Reads target of a freed internal pointer of a COM object</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_COM_deref_write_after_free</key>
        <name>Memory - corruptions : Freed COM internal write</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_COM_deref_write_after_free</internalKey>
        <description>Write to target of a freed internal pointer of a COM object</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_COM_use_after_free</key>
        <name>Memory - illegal accesses : COM object use after free</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_COM_use_after_free</internalKey>
        <description>An internal pointer of a COM string object remains available after the object is freed</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_deref_read_after_free</key>
        <name>Memory - illegal accesses : Freed internal location read</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_deref_read_after_free</internalKey>
        <description>Reads target of a freed internal pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_deref_write_after_free</key>
        <name>Memory - corruptions : Freed internal location write</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_deref_write_after_free</internalKey>
        <description>Write to target of a freed internal pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WRAPPER_ESCAPE_none</key>
        <name>Memory - illegal accesses : Wrapper object use after free</name>
        <internalKey>STATIC_C_WRAPPER_ESCAPE_none</internalKey>
        <description>An internal pointer of a wrapper object remains available after the object is freed</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.CLEANUP_STACK_bad_pop_arg</key>
        <name>API usage errors : Symbian - wrong object popped</name>
        <internalKey>STATIC_C_SYMBIAN.CLEANUP_STACK_bad_pop_arg</internalKey>
        <description>The cleanup stack is not empty at the end of the function, or function pops elements incorrectly</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.CLEANUP_STACK_double_free</key>
        <name>Memory - corruptions : Symbian - double free</name>
        <internalKey>STATIC_C_SYMBIAN.CLEANUP_STACK_double_free</internalKey>
        <description>An object is freed twice because it is explicitly freed twice, on the cleanup stack more than once, or it is deallocated but still on the cleanup stack</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.CLEANUP_STACK_leak</key>
        <name>Resource leaks : Symbian - cleanup stack leak</name>
        <internalKey>STATIC_C_SYMBIAN.CLEANUP_STACK_leak</internalKey>
        <description>An object is not on the cleanup stack when a leave occurs or an allocated object goes out of scope, causing a leak</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.CLEANUP_STACK_multiple_pushes</key>
        <name>API usage errors : Symbian - several objects pushed</name>
        <internalKey>STATIC_C_SYMBIAN.CLEANUP_STACK_multiple_pushes</internalKey>
        <description>A function pushes more than one object onto the cleanup stack in at least one possible execution</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SYMBIAN.CLEANUP_STACK_none</key>
        <name>Resource leaks : Symbian - cleanup stack bug</name>
        <internalKey>STATIC_C_SYMBIAN.CLEANUP_STACK_none</internalKey>
        <description>Error in the interaction of the code with the Symbian cleanup stack API</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DIVIDE_BY_ZERO_float_divisor</key>
        <name>Incorrect expression : Division or modulo by float zero</name>
        <internalKey>STATIC_C_DIVIDE_BY_ZERO_float_divisor</internalKey>
        <description>An expression which may be zero is used as a divisor in floating-point arithmetic.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DIVIDE_BY_ZERO_none</key>
        <name>Integer handling issues : Division or modulo by zero</name>
        <internalKey>STATIC_C_DIVIDE_BY_ZERO_none</internalKey>
        <description>Division or modulo by zero results in undefined behavior.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_COMMA_none</key>
        <name>Incorrect expression : Missing comma in a string array initialization</name>
        <internalKey>STATIC_C_MISSING_COMMA_none</internalKey>
        <description>A comma is suspiciously missing between lines in a string array initialization.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_none</key>
        <name>Integer handling issues : Lossy integer to pointer</name>
        <internalKey>STATIC_C_PW.CONVERSION_TO_POINTER_LOSES_BITS_none</internalKey>
        <description>A cast from an integer to a pointer of narrower precision</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DELETE_VOID_none</key>
        <name>Memory - illegal accesses : Deleting void pointer</name>
        <internalKey>STATIC_C_DELETE_VOID_none</internalKey>
        <description>Deleting a void pointer (void*)</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_deref_read_after_free</key>
        <name>Memory - illegal accesses : Read from pointer after free</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_deref_read_after_free</internalKey>
        <description>Reads target of a freed pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_deref_write_after_free</key>
        <name>Memory - corruptions : Write to pointer after free</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_deref_write_after_free</internalKey>
        <description>Write to target of a freed pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_double_close</key>
        <name>API usage errors : Double close</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_double_close</internalKey>
        <description>A resource handle or descriptor is closed more than once</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_double_free</key>
        <name>Memory - corruptions : Double free</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_double_free</internalKey>
        <description>Memory is deallocated more than once</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_none</key>
        <name>Memory - illegal accesses : Use after free</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_none</internalKey>
        <description>A pointer to freed memory is  dereferenced, used as a function argument, or otherwise used</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_USE_AFTER_FREE_use_after_close</key>
        <name>API usage errors : Use after close</name>
        <internalKey>STATIC_C_USE_AFTER_FREE_use_after_close</internalKey>
        <description>A resource handle or descriptor is used after being closed</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_array_index_read</key>
        <name>Memory - illegal accesses : Overflowed array index read</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_array_index_read</internalKey>
        <description>Read from array at integer overflowed index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_array_index_write</key>
        <name>Memory - corruptions : Overflowed array index write</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_array_index_write</internalKey>
        <description>Write to array at integer-overflowed index</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_const_overflow</key>
        <name>Integer handling issues : Overflowed constant</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_const_overflow</internalKey>
        <description>Integer overflow  occurs in arithmetic on constant operands</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_critical_argument</key>
        <name>Insecure data handling : Integer overflowed argument</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_critical_argument</internalKey>
        <description>An integer overflow occurs, with the overflowed value used as an argument to a function</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_none</key>
        <name>Insecure data handling : Integer overflow</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_none</internalKey>
        <description>An integer overflow occurs, with the overflowed value used in a sensitive operation</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_pointer_deref_read</key>
        <name>Memory - illegal accesses : Overflowed pointer read</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_pointer_deref_read</internalKey>
        <description>Reads target of an integer-overflowed pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_pointer_deref_write</key>
        <name>Memory - corruptions : Overflowed pointer write</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_pointer_deref_write</internalKey>
        <description>Write to target of an integer-overflowed pointer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_INTEGER_OVERFLOW_return_value_error</key>
        <name>Insecure data handling : Overflowed return value</name>
        <internalKey>STATIC_C_INTEGER_OVERFLOW_return_value_error</internalKey>
        <description>An integer overflow occurs, with the overflowed value used as the return value of the function</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_bitwise_op_bad_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_bitwise_op_bad_cast</internalKey>
        <description>Bitwise operator &amp;lt;&amp;lt; applies to operand with underlying type unsigned short is cast to int (MISRA 2004 Rule 10.5)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_bitwise_op_no_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_bitwise_op_no_cast</internalKey>
        <description>Bitwise operator &amp;lt;&amp;lt; applies to operand with underlying type unsigned short is not being immediately cast to that type (MISRA 2004 Rule 10.5)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_complex_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_complex_conversion</internalKey>
        <description>Implicitly converting complex expression from float to double (MISRA 2004 Rule 10.2)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_narrowing_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_narrowing_conversion</internalKey>
        <description>Implicitly converting a double expression to narrower float type may lose precision (MISRA 2004 Rule 10.2)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_non_constant_arg_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_non_constant_arg_conversion</internalKey>
        <description>Implicit conversion from float to double in a function argument (MISRA 2004 Rule 10.2)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_non_constant_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_non_constant_conversion</internalKey>
        <description>Implicit conversion from float to double in a function argument (MISRA-2008 Rule 5-0-3)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_non_constant_rtn_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_non_constant_rtn_conversion</internalKey>
        <description>Implicit conversion from float to double in a return expression (MISRA 2004 Rule 10.2)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_to_integer_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_float_to_integer_cast</internalKey>
        <description>Complex expression cast from 64-bit float to 16-bit int (MISRA 2004 Rule 10.4)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_to_integer_conversion</key>
        <name>Integer handling issues : Implicit floating conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_float_to_integer_conversion</internalKey>
        <description>Implicit conversion from float to 16-bit integer type (MISRA 2004 Rule 10.2)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_float_widening_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_float_widening_cast</internalKey>
        <description>Complex expression cast from 32-bit float to 64-bit float (MISRA 2004 Rule 10.4)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_complex_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_complex_conversion</internalKey>
        <description>Implicitly converting the type of a complex expression (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_narrowing_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_narrowing_conversion</internalKey>
        <description>Implicitly converting an integer expression to a narrower integer type may truncate value (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_non_constant_arg_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_non_constant_arg_conversion</internalKey>
        <description>Implicitly converting the integer type of a non-constant function argument expression (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_non_constant_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_non_constant_conversion</internalKey>
        <description>Implicitly converting the integer type of a non-constant function argument expression (MISRA-2008 Rule 5-0-3)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_non_constant_rtn_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_non_constant_rtn_conversion</internalKey>
        <description>Implicitly converting the integer type of a non-constant return expression (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_signedness_changing_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_signedness_changing_cast</internalKey>
        <description>Complex expression cast from 32-bit int to 32-bit unsigned int (MISRA 2004 Rule 10.3)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_signedness_changing_conversion</key>
        <name>Integer handling issues : Implicit integer conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_signedness_changing_conversion</internalKey>
        <description>Implicitly converting the signedness of an integer value (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_to_float_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_to_float_cast</internalKey>
        <description>Complex expression cast from int to 64-bit float (MISRA 2004 Rule 10.3)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_to_float_conversion</key>
        <name>Integer handling issues : Implicit conversion</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_to_float_conversion</internalKey>
        <description>Implicitly converting complex expression with integer type to floating type (MISRA 2004 Rule 10.1)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_integer_widening_cast</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_integer_widening_cast</internalKey>
        <description>Complex expression with underlying type 16-bit unsigned value cast to wider type 32-bit unsigned value (MISRA 2004 Rule 10.3)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISRA_CAST_none</key>
        <name>Integer handling issues : Misra violating cast</name>
        <internalKey>STATIC_C_MISRA_CAST_none</internalKey>
        <description>Cast operation violates MISRA standard (MISRA 2004 Rules 10.1 - 10.5)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ARRAY_VS_SINGLETON_none</key>
        <name>Memory - corruptions : Out-of-bounds access</name>
        <internalKey>STATIC_C_ARRAY_VS_SINGLETON_none</internalKey>
        <description>Access of memory past the end of a memory buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRAY_SEMICOLON_none</key>
        <name>Control flow issues : Stray semicolon</name>
        <internalKey>STATIC_C_STRAY_SEMICOLON_none</internalKey>
        <description>The code contains a semicolon where it is probably not intended, such as between a &apos;for&apos;, &apos;while&apos;, or &apos;if&apos; and a code block.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ASSERT_SIDE_EFFECT_none</key>
        <name>Incorrect expression : Side effect in assertion</name>
        <internalKey>STATIC_C_ASSERT_SIDE_EFFECT_none</internalKey>
        <description>Assertion contains an operation with a side effect</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ASSERT_SIDE_EFFECT_side_effect_is_function</key>
        <name>Incorrect expression : Function in assertion</name>
        <internalKey>STATIC_C_ASSERT_SIDE_EFFECT_side_effect_is_function</internalKey>
        <description>Assertion contains a function call which may have a side effect</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_COMPARE_comparator_misuse</key>
        <name>API usage errors : Misuse of memcmp-style function</name>
        <internalKey>STATIC_C_BAD_COMPARE_comparator_misuse</internalKey>
        <description>A memcmp-style function is used assuming that it returns -1, 0, or 1.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_COMPARE_misuse_of_not</key>
        <name>Incorrect expression : Unintended comparison to logical negation</name>
        <internalKey>STATIC_C_BAD_COMPARE_misuse_of_not</internalKey>
        <description>Logical negation is applied to a comparison operand instead of the comparison result.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_COMPARE_none</key>
        <name>Incorrect expression : Function address comparison</name>
        <internalKey>STATIC_C_BAD_COMPARE_none</internalKey>
        <description>Address of function compared to zero</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_COMPARE_null_misuse</key>
        <name>Incorrect expression : Inequality comparison against NULL</name>
        <internalKey>STATIC_C_BAD_COMPARE_null_misuse</internalKey>
        <description>Comparing a pointer against NULL using an operator such as &lt; or &gt;=.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_COMPARE_string_lit_comparison</key>
        <name>Incorrect expression : Pointer comparison with string literal</name>
        <internalKey>STATIC_C_BAD_COMPARE_string_lit_comparison</internalKey>
        <description>Comparing against the address of a string literal.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_PASS_BY_VALUE_none</key>
        <name>Performance inefficiencies : Big parameter passed by value</name>
        <internalKey>STATIC_C_PASS_BY_VALUE_none</internalKey>
        <description>A large function call parameter or exception catch statement is passed by value</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_FORWARD_NULL_deref_constant_null</key>
        <name>Null pointer dereferences : Explicit null dereferenced</name>
        <internalKey>STATIC_C_FORWARD_NULL_deref_constant_null</internalKey>
        <description>Dereference of an explicit null value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_FORWARD_NULL_dynamic_cast</key>
        <name>Null pointer dereferences : Unchecked dynamic_cast</name>
        <internalKey>STATIC_C_FORWARD_NULL_dynamic_cast</internalKey>
        <description>Dynamic_cast may fail and return null if the type cast is incompatible</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_FORWARD_NULL_none</key>
        <name>Null pointer dereferences : Dereference after null check</name>
        <internalKey>STATIC_C_FORWARD_NULL_none</internalKey>
        <description>Pointer is checked against null but then dereferenced anyway</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNUSED_VALUE_adjacent</key>
        <name>Incorrect expression : Unused value</name>
        <internalKey>STATIC_C_UNUSED_VALUE_adjacent</internalKey>
        <description>A value assigned to a variable is never used.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNUSED_VALUE_none</key>
        <name>Code maintainability issues : Unused value</name>
        <internalKey>STATIC_C_UNUSED_VALUE_none</internalKey>
        <description>A value assigned to a variable is never used.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERRUN_illegal_address</key>
        <name>Memory - corruptions : Illegal address computation</name>
        <internalKey>STATIC_C_OVERRUN_illegal_address</internalKey>
        <description>An illegal address is computed, which either precedes a buffer or is more than just-past its end</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERRUN_none</key>
        <name>Memory - corruptions : Out-of-bounds access</name>
        <internalKey>STATIC_C_OVERRUN_none</internalKey>
        <description>Out-of-bounds access to a buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERRUN_read</key>
        <name>Memory - illegal accesses : Out-of-bounds read</name>
        <internalKey>STATIC_C_OVERRUN_read</internalKey>
        <description>Out-of-bounds read from a buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERRUN_strlen</key>
        <name>Memory - corruptions : Allocation size error</name>
        <internalKey>STATIC_C_OVERRUN_strlen</internalKey>
        <description>Allocation size does not include space for the null-terminator needed for a string</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERRUN_write</key>
        <name>Memory - corruptions : Out-of-bounds write</name>
        <internalKey>STATIC_C_OVERRUN_write</internalKey>
        <description>Out-of-bounds write to a buffer</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_COPY_PASTE_ERROR_none</key>
        <name>Incorrect expression : Copy-paste error</name>
        <internalKey>STATIC_C_COPY_PASTE_ERROR_none</internalKey>
        <description>A copied piece of code is inconsistent with the original</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SELF_ASSIGN_none</key>
        <name>Rule violations : Unsafe assignment operator</name>
        <internalKey>STATIC_C_SELF_ASSIGN_none</internalKey>
        <description>Assignment operator does not check for self-assignment</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NESTING_INDENT_MISMATCH_bad_indentation</key>
        <name>Code maintainability issues : Indentation does not match nesting level</name>
        <internalKey>STATIC_C_NESTING_INDENT_MISMATCH_bad_indentation</internalKey>
        <description>The indentation of this code does not reflect its syntactic nesting level.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NESTING_INDENT_MISMATCH_none</key>
        <name>Control flow issues : Nesting level does not match indentation</name>
        <internalKey>STATIC_C_NESTING_INDENT_MISMATCH_none</internalKey>
        <description>The indentation of this code suggests it is nested when it is not.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_CTOR_none</key>
        <name>Uninitialized members : Uninitialized scalar field</name>
        <internalKey>STATIC_C_UNINIT_CTOR_none</internalKey>
        <description>A scalar field is not initialized by the constructor</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_UNINIT_CTOR_pointer</key>
        <name>Uninitialized members : Uninitialized pointer field</name>
        <internalKey>STATIC_C_UNINIT_CTOR_pointer</internalKey>
        <description>A pointer field is not initialized in the constructor</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_MOVE_ASSIGNMENT_none</key>
        <name>Low impact quality : Missing move assignment operator</name>
        <internalKey>STATIC_C_MISSING_MOVE_ASSIGNMENT_none</internalKey>
        <description>Class lacks a user-written move assignment operator</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_OVERFLOW_BEFORE_WIDEN_none</key>
        <name>Integer handling issues : Unintentional integer overflow</name>
        <internalKey>STATIC_C_OVERFLOW_BEFORE_WIDEN_none</internalKey>
        <description>An integer overflow occurs, with the result converted to a wider integer type</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_CHROOT_none</key>
        <name>API usage errors : Insecure chroot</name>
        <internalKey>STATIC_C_CHROOT_none</internalKey>
        <description>A call to chroot followed by an operation that may escape from the chroot jail</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISMATCHED_ITERATOR_mismatched_comparison</key>
        <name>Control flow issues : Invalid iterator comparison</name>
        <internalKey>STATIC_C_MISMATCHED_ITERATOR_mismatched_comparison</internalKey>
        <description>Iterators that point to different containers are compared</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISMATCHED_ITERATOR_none</key>
        <name>Memory - corruptions : Iterator container mismatch</name>
        <internalKey>STATIC_C_MISMATCHED_ITERATOR_none</internalKey>
        <description>Using iterator from one container in operations on another container</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISMATCHED_ITERATOR_splice_iterator_mismatch</key>
        <name>Memory - corruptions : Splice iterator mismatch</name>
        <internalKey>STATIC_C_MISMATCHED_ITERATOR_splice_iterator_mismatch</internalKey>
        <description>Using iterator from the wrong container as argument to the splice method</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_STRING_WARNING_format_string</key>
        <name>Security best practices violations : Format string warning</name>
        <internalKey>STATIC_C_TAINTED_STRING_WARNING_format_string</internalKey>
        <description>A non-constant string used to construct a format string</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_TAINTED_STRING_WARNING_none</key>
        <name>Security best practices violations : Format string warning</name>
        <internalKey>STATIC_C_TAINTED_STRING_WARNING_none</internalKey>
        <description>A non-constant string used to construct a format string</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_TOCTOU_none</key>
        <name>Security best practices violations : Time of check time of use</name>
        <internalKey>STATIC_C_TOCTOU_none</internalKey>
        <description>A check occurs on a file&apos;s attributes before the file is used in a privileged operation, but things may have changed</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_none</key>
        <name>Integer handling issues : Unsigned compared with neg</name>
        <internalKey>STATIC_C_PW.UNSIGNED_COMPARE_WITH_NEGATIVE_none</internalKey>
        <description>An unsigned value, which can never be less than 0, is compared with a negative value</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NEGATIVE_RETURNS_array_index_read</key>
        <name>Memory - illegal accesses : Negative array index read</name>
        <internalKey>STATIC_C_NEGATIVE_RETURNS_array_index_read</internalKey>
        <description>Negative value used to index an array in a read operation</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NEGATIVE_RETURNS_array_index_write</key>
        <name>Memory - corruptions : Negative array index write</name>
        <internalKey>STATIC_C_NEGATIVE_RETURNS_array_index_write</internalKey>
        <description>Negative value used to index an array in a write operation</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NEGATIVE_RETURNS_critical_argument</key>
        <name>Error handling issues : Argument cannot be negative</name>
        <internalKey>STATIC_C_NEGATIVE_RETURNS_critical_argument</internalKey>
        <description>Negative value used as  argument to a function expecting a positive value (for example, size of buffer or allocation)</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NEGATIVE_RETURNS_loop_bound</key>
        <name>Program hangs : Negative loop bound</name>
        <internalKey>STATIC_C_NEGATIVE_RETURNS_loop_bound</internalKey>
        <description>Negative value used as a loop upper bound</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_NEGATIVE_RETURNS_none</key>
        <name>Integer handling issues : Improper use of negative value</name>
        <internalKey>STATIC_C_NEGATIVE_RETURNS_none</internalKey>
        <description>Negative value can be returned from function is not being checked before being used improperly</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_dns</key>
        <name>Low impact security : Check against reverse DNS lookup</name>
        <internalKey>STATIC_C_WEAK_GUARD_dns</internalKey>
        <description>Comparing the result of a reverse DNS lookup to a hardcoded hostname.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_dns_sensitive_op</key>
        <name>High impact security : Check against reverse DNS lookup</name>
        <internalKey>STATIC_C_WEAK_GUARD_dns_sensitive_op</internalKey>
        <description>Using the results of a reverse DNS lookup to guard a sensitive operation.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_http_referer</key>
        <name>Low impact security : Comparison of HTTP referer to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_http_referer</internalKey>
        <description>Comparing the HTTP &apos;referer&apos; header to a hardcoded value.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_http_referer_sensitive_op</key>
        <name>High impact security : Comparison of HTTP referer to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_http_referer_sensitive_op</internalKey>
        <description>Using the HTTP &apos;referer&apos; header value as a security control for a sensitive operation.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_ip_address</key>
        <name>Low impact security : Comparison of IP address to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_ip_address</internalKey>
        <description>Comparing a remote connection&apos;s IP address against a hardcoded value.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_ip_address_sensitive_op</key>
        <name>High impact security : Comparison of IP address to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_ip_address_sensitive_op</internalKey>
        <description>Using an IP address as a security control for a sensitive operation.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_none</key>
        <name>Low impact security : Check against unreliable data</name>
        <internalKey>STATIC_C_WEAK_GUARD_none</internalKey>
        <description>Performing a check against unreliable data that an attacker can control</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_os_login</key>
        <name>Low impact security : Comparison of OS login to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_os_login</internalKey>
        <description>Comparing a user&apos;s operating system login name to a constant.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_os_login_sensitive_op</key>
        <name>High impact security : Comparison of OS login to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_os_login_sensitive_op</internalKey>
        <description>Comparing a user&apos;s operating system login name to a constant to guard a sensitive operation.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_principal_name</key>
        <name>Low impact security : Comparison of principal name to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_principal_name</internalKey>
        <description>Comparing the name of a principal to a constant.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_WEAK_GUARD_principal_name_sensitive_op</key>
        <name>High impact security : Comparison of principal name to a constant</name>
        <internalKey>STATIC_C_WEAK_GUARD_principal_name_sensitive_op</internalKey>
        <description>Comparing the name of a principal to a constant to guard a sensitive operation.</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.NE_NON_BSTR_none</key>
        <name>API usage errors : COM BSTR inequality with non-BSTR</name>
        <internalKey>STATIC_C_COM.BSTR.NE_NON_BSTR_none</internalKey>
        <description>Comparison of BSTR to other than BSTR</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_IDENTICAL_BRANCHES_case</key>
        <name>Incorrect expression : Identical code for different cases</name>
        <internalKey>STATIC_C_IDENTICAL_BRANCHES_case</internalKey>
        <description>The same code is executed for two cases in the same switch statement</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_IDENTICAL_BRANCHES_chain</key>
        <name>Incorrect expression : Identical code for different branches of an else-if chain</name>
        <internalKey>STATIC_C_IDENTICAL_BRANCHES_chain</internalKey>
        <description>The same code is executed regardless of the condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_IDENTICAL_BRANCHES_if</key>
        <name>Incorrect expression : Identical code for different branches</name>
        <internalKey>STATIC_C_IDENTICAL_BRANCHES_if</internalKey>
        <description>The same code is executed regardless of the condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_IDENTICAL_BRANCHES_ternary</key>
        <name>Incorrect expression : Identical code for different branches</name>
        <internalKey>STATIC_C_IDENTICAL_BRANCHES_ternary</internalKey>
        <description>The same code is executed regardless of the condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_IDENTICAL_BRANCHES_none</key>
        <name>Incorrect expression : Identical code for different branches</name>
        <internalKey>STATIC_C_IDENTICAL_BRANCHES_none</internalKey>
        <description>The same code is executed regardless of the condition</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DC.STRING_BUFFER_none</key>
        <name>Security best practices violations : Calling risky function</name>
        <internalKey>STATIC_C_DC.STRING_BUFFER_none</internalKey>
        <description>The called function is unsafe for security related code</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>VULNERABILITY</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_RESTORE_likely</key>
        <name>Control flow issues : Failure to restore non-local value</name>
        <internalKey>STATIC_C_MISSING_RESTORE_likely</internalKey>
        <description>Handles classes of flow where a function is either saving some external value, modifying the external value, and then clearly intending to restore it to its original state but failing to do so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then clearly intending to restore it to the expected value but failing to do so along a path.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_RESTORE_none</key>
        <name>Control flow issues : Failure to restore non-local value</name>
        <internalKey>STATIC_C_MISSING_RESTORE_none</internalKey>
        <description>Handles classes of flow where a function is either saving some external value, modifying the external value, and then clearly intending to restore it to its original state but failing to do so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then clearly intending to restore it to the expected value but failing to do so along a path.</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_MISSING_RESTORE_possible</key>
        <name>Possible Control flow issues : Possible failure to restore non-local value</name>
        <internalKey>STATIC_C_MISSING_RESTORE_possible</internalKey>
        <description>Handles classes of flow where a function is either saving some external value, modifying the external value, and then possibly intending to restore it to its original state but not doing so along one of many paths; or else is checking whether an external has some expected value, modifying the external value, then possibly intending to restore it to the expected value but not doing so along a path.  Such code is only incorrect if the intent really was to restore along all paths.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_none</key>
        <name>Control flow issues : Branch past initialization</name>
        <internalKey>STATIC_C_PW.BRANCH_PAST_INITIALIZATION_none</internalKey>
        <description>A goto jumps past the initialization of a variable</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INCOMPATIBLE_CAST_endianness</key>
        <name>Integer handling issues : Reliance on integer endianness</name>
        <internalKey>STATIC_C_INCOMPATIBLE_CAST_endianness</internalKey>
        <description>Reliance on integer endianness</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INCOMPATIBLE_CAST_float_vs_integral</key>
        <name>Integer handling issues : Incompatible cast</name>
        <internalKey>STATIC_C_INCOMPATIBLE_CAST_float_vs_integral</internalKey>
        <description>Cast between floating-point and integral pointers</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INCOMPATIBLE_CAST_none</key>
        <name>Integer handling issues : Incompatible pointer cast</name>
        <internalKey>STATIC_C_INCOMPATIBLE_CAST_none</internalKey>
        <description>Cast between incompatible pointer types</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_INCOMPATIBLE_CAST_overrun</key>
        <name>Memory - illegal accesses : Out-of-bounds access</name>
        <internalKey>STATIC_C_INCOMPATIBLE_CAST_overrun</internalKey>
        <description>Out-of-bounds access to a scalar</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_indirect</key>
        <name>Strict rule violations : Assign does not return *this</name>
        <internalKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_indirect</internalKey>
        <description>A user-written assignment operator does not return a reference to *this</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_none</key>
        <name>Rule violations : Assign does not return *this</name>
        <internalKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_none</internalKey>
        <description>A user-written assignment operator does not return a reference to *this</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_usable_for_chained_assignment</key>
        <name>Strict rule violations : Assign does not return *this</name>
        <internalKey>STATIC_C_ASSIGN_NOT_RETURNING_STAR_THIS_usable_for_chained_assignment</internalKey>
        <description>A user-written assignment operator does not return a reference to *this</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.EXPR_HAS_NO_EFFECT_none</key>
        <name>Incorrect expression : Expression with no effect</name>
        <internalKey>STATIC_C_PW.EXPR_HAS_NO_EFFECT_none</internalKey>
        <description>An expression with no side-effect or unintended effect indicates a possible logic flaw</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_SECURE_TEMP_none</key>
        <name>Security best practices violations : Insecure temporary file</name>
        <internalKey>STATIC_C_SECURE_TEMP_none</internalKey>
        <description>Using an insecure temporary file creation function</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_BAD_OVERRIDE_none</key>
        <name>Class hierarchy inconsistencies : Failed to override method</name>
        <internalKey>STATIC_C_BAD_OVERRIDE_none</internalKey>
        <description>Virtual function does not override parent method because of type signature mismatch, usually due to const</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.INTEGER_OVERFLOW_none</key>
        <name>Integer handling issues : Integer overflow warning</name>
        <internalKey>STATIC_C_PW.INTEGER_OVERFLOW_none</internalKey>
        <description>An integer overflow occurs at compile time when parsing this expression</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_RW.*</key>
        <name>Coverity RW : Recovery Warnings</name>
        <internalKey>STATIC_C_RW.*</internalKey>
        <description>Coverity RW : Recovery Warnings</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>recovery-warning</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COM.BSTR.BAD_COMPARE_none</key>
        <name>API usage errors : Bad COM BSTR comparison</name>
        <internalKey>STATIC_C_COM.BSTR.BAD_COMPARE_none</internalKey>
        <description>Comparison of two BSTRs for other than equality</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.DIVIDE_BY_ZERO_none</key>
        <name>Integer handling issues : Divide by zero</name>
        <internalKey>STATIC_C_PW.DIVIDE_BY_ZERO_none</internalKey>
        <description>Divide by zero</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_COPY_WITHOUT_ASSIGN_none</key>
        <name>Rule violations : Copy without assign</name>
        <internalKey>STATIC_C_COPY_WITHOUT_ASSIGN_none</internalKey>
        <description>Class has user-written copy constructor but no user-written assignment operator</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DEADCODE_dead_case_in_switch</key>
        <name>Possible Control flow issues : Dead case in switch</name>
        <internalKey>STATIC_C_DEADCODE_dead_case_in_switch</internalKey>
        <description>Switch never goes directly to this case</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DEADCODE_dead_default_in_switch</key>
        <name>Possible Control flow issues : Dead default in switch</name>
        <internalKey>STATIC_C_DEADCODE_dead_default_in_switch</internalKey>
        <description>Default in switch statement is dead code</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DEADCODE_effectively_constant</key>
        <name>Possible Control flow issues : &apos;Constant&apos; variable guards dead code</name>
        <internalKey>STATIC_C_DEADCODE_effectively_constant</internalKey>
        <description>Variable assigned once to a constant guards dead code.</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DEADCODE_none</key>
        <name>Control flow issues : Logically dead code</name>
        <internalKey>STATIC_C_DEADCODE_none</internalKey>
        <description>Code can never be reached because of a logical contradiction</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_DEADCODE_redundant_test</key>
        <name>Possible Control flow issues : Redundant test</name>
        <internalKey>STATIC_C_DEADCODE_redundant_test</internalKey>
        <description>Test always evaluates the same</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_USER_POINTER_none</key>
        <name>Security best practices violations : User pointer dereference</name>
        <internalKey>STATIC_C_USER_POINTER_none</internalKey>
        <description>A user-land pointer is dereferenced without safety checks in the kernel</description>
        <severity>MAJOR</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_STRING_NULL_none</key>
        <name>Memory - illegal accesses : String not null terminated</name>
        <internalKey>STATIC_C_STRING_NULL_none</internalKey>
        <description>A character buffer that has not been null terminated is passed to a function expecting a null terminated string</description>
        <severity>BLOCKER</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
        <tag>security</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_none</key>
        <name>API usage errors : Printf format string issue</name>
        <internalKey>STATIC_C_PW.BAD_PRINTF_FORMAT_STRING_none</internalKey>
        <description>A printf format string contains an unrecognized format specifier</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
    <rule>
        <key>STATIC_C_PW.BAD_CAST_none</key>
        <name>Integer handling issues : Lossy integer to pointer</name>
        <internalKey>STATIC_C_PW.BAD_CAST_none</internalKey>
        <description>A cast from an integer to a pointer of narrower precision</description>
        <severity>CRITICAL</severity>
        <cardinality>SINGLE</cardinality>
        <status>READY</status>
        <type>BUG</type>
        <tag>coverity</tag>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>quality</tag>
    </rule>
</rules>
